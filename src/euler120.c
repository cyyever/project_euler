/*
 *	程序名：euler120.c
 *	作者：陈源源
 *	日期：2014-11-20
 *	功能：解决eulerproject 120题(https://projecteuler.net/problem=120)
 */

#include <stdio.h>
#include <inttypes.h>

/*
 *	功能：获取指定a下的((a−1)^n+(a+1)^n)/a^2的最大余数
 *	参数：
 *		a：待计算的a
 *	返回值：
 *		最大余数
 */
uint64_t rmax(uint64_t a);

int main(void)
{
	uint64_t sum,a;

	sum=0;
	for(a=3;a<=1000;a++)
		sum+=rmax(a);
	printf("%"PRIu64"\n",sum);
	return 0;
}

/*
 *	功能：获取指定a下的((a−1)^n+(a+1)^n)/a^2的最大余数
 *	参数：
 *		a：待计算的a
 *	返回值：
 *		最大余数
 */
uint64_t rmax(uint64_t a)
{
	//由于(a-1)^n==(-1)^n+na*(-1)^(n-1) mod a^2 并且 (a+1)^n==(1)^n+na*(1)^(n-1) mod a^2
	//所以当n为偶数时余数为2，否则余数为2na mod a^2
	//但是当n=1时的余数2a (a>=3) 就已经>2，所以我们只需要考虑n为奇数的情况
	//所以可能的取值为2a 6a 10a ... 接下来我们考虑这个数列wrap的所有case:
	//	1.如果a%4==2，那么当数列撞到a^a时，后面的数列wrap成4a 8a ...，接下去又会wrap成2a开始的数列
	//		因此只有两种可能的数列，一个是从2a开始的，一个从4a开始的，前者最近的项是(a-4)a，后者最近的项是(a-2)a，因此取后者
	//	2.如果a%4==0，那么当数列超过a^a时，被warp成相同的数列，因此最近的项是(a-2)a
	//	3.如果a%4==1，那么当数列超过a^a时，被warp成a 5a 9a ...的数列，接下来被wrap成4a开始的数列，接下来被warp成3a开始的数列，接下来被warp成2a开始的数列
	//		在这四种数列中，最近的项是(a-1)*a
	//	4.如果a%4==3，那么当数列超过a^a时，被warp成3a 7a 11a ...的数列，接下来被wrap成4a开始的数列，接下来被warp成a开始的数列，接下来被warp成2a开始的数列
	//		在这四种数列中，最近的项是(a-1)*a
	// 那么归结起来，如果a是偶数，则取(a-2)*a，否则取(a-1)*a
	return (a-1-((a%2)!=1))*a;
}
